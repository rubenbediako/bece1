import React, { useState } from 'react';
import {
  Box,
  Typography,
  Button,
  TextField,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Alert,
  Paper,
  Chip,
  FormControlLabel,
  Checkbox,
  Stack,
  Card,
  CardContent,
  IconButton,
  Divider,
  Accordion,
  AccordionSummary,
  AccordionDetails
} from '@mui/material';
import { motion } from 'framer-motion';
import { Plus, Edit, Trash2, HelpCircle, ChevronDown, BookOpen } from 'lucide-react';
import type { Subject, Topic, Question } from '../App';

interface QuestionManagerProps {
  subjects: Subject[];
  topics: Topic[];
  questions: Question[];
  setQuestions: React.Dispatch<React.SetStateAction<Question[]>>;
}

const QuestionManager: React.FC<QuestionManagerProps> = ({ 
  subjects, 
  topics, 
  questions, 
  setQuestions 
}) => {
  const [open, setOpen] = useState(false);
  const [editingQuestion, setEditingQuestion] = useState<Question | null>(null);
  const [selectedSubject, setSelectedSubject] = useState('');
  const [expandedAccordion, setExpandedAccordion] = useState<string | false>(false);

  const [formData, setFormData] = useState({
    subjectId: '',
    topicId: '',
    question: '',
    type: 'multiple-choice' as Question['type'],
    options: ['', '', '', ''],
    correctAnswer: '',
    explanation: '',
    solution: '',
    difficulty: 'medium' as Question['difficulty'],
    points: 1
  });

  const handleOpen = (question?: Question) => {
    if (question) {
      setEditingQuestion(question);
      setFormData({
        subjectId: question.subjectId,
        topicId: question.topicId,
        question: question.question,
        type: question.type,
        options: question.options || ['', '', '', ''],
        correctAnswer: question.correctAnswer,
        explanation: question.explanation,
        solution: question.solution,
        difficulty: question.difficulty,
        points: question.points
      });
    } else {
      setEditingQuestion(null);
      setFormData({
        subjectId: '',
        topicId: '',
        question: '',
        type: 'multiple-choice',
        options: ['', '', '', ''],
        correctAnswer: '',
        explanation: '',
        solution: '',
        difficulty: 'medium',
        points: 1
      });
    }
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
    setEditingQuestion(null);
  };

  const handleSave = () => {
    if (!formData.subjectId || !formData.topicId || !formData.question.trim() || 
        !formData.correctAnswer.trim() || !formData.explanation.trim() || !formData.solution.trim()) {
      alert('Please fill in all required fields');
      return;
    }

    const now = new Date().toISOString();

    const questionData = {
      ...formData,
      options: formData.type === 'multiple-choice' ? formData.options.filter(opt => opt.trim()) : undefined
    };

    if (editingQuestion) {
      // Update existing question
      setQuestions(prev => prev.map(q => 
        q.id === editingQuestion.id
          ? {
              ...questionData,
              id: q.id,
              createdAt: q.createdAt,
              updatedAt: now
            }
          : q
      ));
    } else {
      // Create new question
      const newQuestion: Question = {
        ...questionData,
        id: `question-${Date.now()}`,
        createdAt: now,
        updatedAt: now
      };
      setQuestions(prev => [...prev, newQuestion]);
    }

    handleClose();
  };

  const handleDelete = (questionId: string) => {
    if (window.confirm('Are you sure you want to delete this question?')) {
      setQuestions(prev => prev.filter(q => q.id !== questionId));
    }
  };

  const handleSubjectChange = (subjectId: string) => {
    setFormData(prev => ({ ...prev, subjectId, topicId: '' }));
  };

  const getTopicsForSubject = (subjectId: string) => {
    return topics.filter(t => t.subjectId === subjectId);
  };

  const getSubjectName = (subjectId: string) => {
    return subjects.find(s => s.id === subjectId)?.name || 'Unknown Subject';
  };

  const getTopicName = (topicId: string) => {
    return topics.find(t => t.id === topicId)?.name || 'Unknown Topic';
  };

  const filteredQuestions = selectedSubject 
    ? questions.filter(q => q.subjectId === selectedSubject)
    : questions;

  const groupedQuestions = filteredQuestions.reduce((acc, question) => {
    const key = `${question.subjectId}-${question.topicId}`;
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(question);
    return acc;
  }, {} as Record<string, Question[]>);

  return (
    <Box>
      <Paper elevation={1} sx={{ p: 3, mb: 4, backgroundColor: 'primary.main', color: 'white' }}>
        <Typography variant="h4" gutterBottom fontWeight="bold">
          üìù Question Management
        </Typography>
        <Typography variant="h6" sx={{ opacity: 0.9 }}>
          Create and manage questions with detailed solutions
        </Typography>
      </Paper>

      {/* Controls */}
      <Stack direction="row" spacing={2} sx={{ mb: 3 }} flexWrap="wrap">
        <Button
          variant="contained"
          startIcon={<Plus size={20} />}
          onClick={() => handleOpen()}
          size="large"
        >
          Add New Question
        </Button>

        <FormControl sx={{ minWidth: 200 }}>
          <InputLabel>Filter by Subject</InputLabel>
          <Select
            value={selectedSubject}
            onChange={(e) => setSelectedSubject(e.target.value)}
            label="Filter by Subject"
          >
            <MenuItem value="">All Subjects</MenuItem>
            {subjects.map((subject) => (
              <MenuItem key={subject.id} value={subject.id}>
                {subject.name}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
      </Stack>

      {/* Questions List */}
      {Object.keys(groupedQuestions).length === 0 ? (
        <Alert severity="info">
          No questions found. Add your first question to get started.
        </Alert>
      ) : (
        <Box>
          {Object.entries(groupedQuestions).map(([key, questionsGroup]) => {
            const firstQuestion = questionsGroup[0];
            const subjectName = getSubjectName(firstQuestion.subjectId);
            const topicName = getTopicName(firstQuestion.topicId);
            
            return (
              <Accordion
                key={key}
                expanded={expandedAccordion === key}
                onChange={(_, isExpanded) => setExpandedAccordion(isExpanded ? key : false)}
                sx={{ mb: 2 }}
              >
                <AccordionSummary expandIcon={<ChevronDown />}>
                  <Box sx={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                    <BookOpen size={20} color="#1976d2" />
                    <Typography variant="h6" sx={{ ml: 1, flexGrow: 1 }}>
                      {subjectName} - {topicName}
                    </Typography>
                    <Chip 
                      label={`${questionsGroup.length} question${questionsGroup.length > 1 ? 's' : ''}`} 
                      size="small" 
                      color="primary" 
                    />
                  </Box>
                </AccordionSummary>
                <AccordionDetails>
                  <Stack spacing={2}>
                    {questionsGroup.map((question, index) => (
                      <motion.div
                        key={question.id}
                        initial={{ opacity: 0, y: 10 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ duration: 0.3, delay: index * 0.1 }}
                      >
                        <Card variant="outlined">
                          <CardContent>
                            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                              <Stack direction="row" spacing={1}>
                                <Chip label={question.type} size="small" />
                                <Chip 
                                  label={question.difficulty} 
                                  size="small" 
                                  color={
                                    question.difficulty === 'easy' ? 'success' : 
                                    question.difficulty === 'medium' ? 'warning' : 'error'
                                  } 
                                />
                                <Chip label={`${question.points} pts`} size="small" variant="outlined" />
                              </Stack>
                              <Box>
                                <IconButton onClick={() => handleOpen(question)} size="small">
                                  <Edit size={16} />
                                </IconButton>
                                <IconButton 
                                  onClick={() => handleDelete(question.id)} 
                                  size="small"
                                  color="error"
                                >
                                  <Trash2 size={16} />
                                </IconButton>
                              </Box>
                            </Box>

                            <Typography variant="h6" gutterBottom>
                              {question.question}
                            </Typography>

                            {question.type === 'multiple-choice' && question.options && (
                              <Box sx={{ ml: 2, mb: 2 }}>
                                {question.options.map((option, idx) => (
                                  <Typography 
                                    key={idx} 
                                    variant="body2" 
                                    sx={{ 
                                      color: option === question.correctAnswer ? 'success.main' : 'text.primary',
                                      fontWeight: option === question.correctAnswer ? 'bold' : 'normal'
                                    }}
                                  >
                                    {String.fromCharCode(65 + idx)}. {option}
                                    {option === question.correctAnswer && ' ‚úì'}
                                  </Typography>
                                ))}
                              </Box>
                            )}

                            <Divider sx={{ my: 2 }} />

                            <Typography variant="subtitle2" color="primary" gutterBottom>
                              Explanation:
                            </Typography>
                            <Typography variant="body2" paragraph>
                              {question.explanation}
                            </Typography>

                            <Typography variant="subtitle2" color="secondary" gutterBottom>
                              Detailed Solution:
                            </Typography>
                            <Typography variant="body2" sx={{ whiteSpace: 'pre-line' }}>
                              {question.solution}
                            </Typography>
                          </CardContent>
                        </Card>
                      </motion.div>
                    ))}
                  </Stack>
                </AccordionDetails>
              </Accordion>
            );
          })}
        </Box>
      )}

      {/* Add/Edit Question Dialog */}
      <Dialog open={open} onClose={handleClose} maxWidth="lg" fullWidth>
        <DialogTitle>
          {editingQuestion ? 'Edit Question' : 'Add New Question'}
        </DialogTitle>
        <DialogContent>
          <Stack spacing={3} sx={{ mt: 1 }}>
            {/* Subject and Topic Selection */}
            <Box sx={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 2 }}>
              <FormControl fullWidth>
                <InputLabel>Subject *</InputLabel>
                <Select
                  value={formData.subjectId}
                  onChange={(e) => handleSubjectChange(e.target.value)}
                  label="Subject *"
                >
                  {subjects.map((subject) => (
                    <MenuItem key={subject.id} value={subject.id}>
                      {subject.name}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>

              <FormControl fullWidth disabled={!formData.subjectId}>
                <InputLabel>Topic *</InputLabel>
                <Select
                  value={formData.topicId}
                  onChange={(e) => setFormData(prev => ({ ...prev, topicId: e.target.value }))}
                  label="Topic *"
                >
                  {getTopicsForSubject(formData.subjectId).map((topic) => (
                    <MenuItem key={topic.id} value={topic.id}>
                      {topic.name}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Box>

            {/* Question Details */}
            <TextField
              label="Question *"
              fullWidth
              multiline
              rows={3}
              value={formData.question}
              onChange={(e) => setFormData(prev => ({ ...prev, question: e.target.value }))}
              placeholder="Enter the question here..."
            />

            <Box sx={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: 2 }}>
              <FormControl fullWidth>
                <InputLabel>Type</InputLabel>
                <Select
                  value={formData.type}
                  onChange={(e) => setFormData(prev => ({ ...prev, type: e.target.value as Question['type'] }))}
                  label="Type"
                >
                  <MenuItem value="multiple-choice">Multiple Choice</MenuItem>
                  <MenuItem value="short-answer">Short Answer</MenuItem>
                  <MenuItem value="essay">Essay</MenuItem>
                  <MenuItem value="practical">Practical</MenuItem>
                </Select>
              </FormControl>

              <FormControl fullWidth>
                <InputLabel>Difficulty</InputLabel>
                <Select
                  value={formData.difficulty}
                  onChange={(e) => setFormData(prev => ({ ...prev, difficulty: e.target.value as Question['difficulty'] }))}
                  label="Difficulty"
                >
                  <MenuItem value="easy">Easy</MenuItem>
                  <MenuItem value="medium">Medium</MenuItem>
                  <MenuItem value="hard">Hard</MenuItem>
                </Select>
              </FormControl>

              <TextField
                label="Points"
                type="number"
                value={formData.points}
                onChange={(e) => setFormData(prev => ({ ...prev, points: parseInt(e.target.value) || 1 }))}
                inputProps={{ min: 1, max: 20 }}
              />
            </Box>

            {/* Multiple Choice Options */}
            {formData.type === 'multiple-choice' && (
              <Box>
                <Typography variant="subtitle1" gutterBottom>
                  Answer Options:
                </Typography>
                <Stack spacing={2}>
                  {formData.options.map((option, index) => (
                    <TextField
                      key={index}
                      label={`Option ${String.fromCharCode(65 + index)}`}
                      value={option}
                      onChange={(e) => {
                        const newOptions = [...formData.options];
                        newOptions[index] = e.target.value;
                        setFormData(prev => ({ ...prev, options: newOptions }));
                      }}
                      placeholder={`Enter option ${String.fromCharCode(65 + index)}`}
                    />
                  ))}
                </Stack>
              </Box>
            )}

            {/* Correct Answer */}
            <TextField
              label="Correct Answer *"
              fullWidth
              value={formData.correctAnswer}
              onChange={(e) => setFormData(prev => ({ ...prev, correctAnswer: e.target.value }))}
              placeholder={formData.type === 'multiple-choice' ? 'Enter the correct option text' : 'Enter the correct answer'}
            />

            {/* Explanation */}
            <TextField
              label="Explanation *"
              fullWidth
              multiline
              rows={3}
              value={formData.explanation}
              onChange={(e) => setFormData(prev => ({ ...prev, explanation: e.target.value }))}
              placeholder="Brief explanation of why this is the correct answer"
            />

            {/* Detailed Solution */}
            <TextField
              label="Detailed Solution *"
              fullWidth
              multiline
              rows={5}
              value={formData.solution}
              onChange={(e) => setFormData(prev => ({ ...prev, solution: e.target.value }))}
              placeholder="Step-by-step solution with working and reasoning..."
            />
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Cancel</Button>
          <Button onClick={handleSave} variant="contained">
            {editingQuestion ? 'Update' : 'Create'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default QuestionManager;
